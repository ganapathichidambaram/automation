name: Approve and Trigger Product Workflow

permissions:
  issues: write
  actions: write
  contents: write

on:
  issue_comment:
    types: [created]

jobs:
  check_approval_and_trigger:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Generate GitHub App Token
        id: generate_token
        uses: tibdex/github-app-token@v1
        with:
          app_id: ${{ secrets.APP_ID }}
          private_key: ${{ secrets.PRIVATE_KEY }}

      - name: Check if Comment is Approval
        if: github.event.comment.body == 'Approve'
        uses: actions/github-script@v6
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const issue = context.payload.issue;
            const comment = context.payload.comment;
            const commenterLogin = comment.user.login;
            const allowedManagers = {
              'int': ['ganapathichidambaram', 'managerA2'],
              'e2em': ['ganapathichidambaram', 'managerB2'],
              'ProductC': ['ganapathichidambaram', 'managerC2']
            };

            const issueBody = issue.body;
            console.log("Issue Body:", issueBody);

            // --- Parse Issue Body to Extract Data ---
            const productMatch = issueBody.match(/###\s*Product\s*\n([^\n]+)/);
            const environmentMatch = issueBody.match(/###\s*Environment\s*\n([^\n]+)/);
            const startDateMatch = issueBody.match(/###\s*Start Date & Time \(YYYY-MM-DD HH:mm\)\s*\n([^\n]+)/);
            const endDateMatch = issueBody.match(/###\s*End Date & Time \(YYYY-MM-DD HH:mm\)\s*\n([^\n]+)/);

            let products = productMatch ? productMatch[1].split(',').map(p => p.trim()) : [];
            let environment = environmentMatch ? environmentMatch[1].trim() : null;
            let startDate = startDateMatch ? startDateMatch[1].trim() : null;
            let endDate = endDateMatch ? endDateMatch[1].trim() : null;

            if (!products.length || !environment || !startDate || !endDate) {
              console.error("Could not extract Product, Environment, Start Date, or End Date from issue body.");
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: "Error: Could not automatically extract Product, Environment, Start Date, or End Date from the issue. Please ensure the issue template was used correctly."
              });
              return;
            }

            // Check if the commenter is an allowed manager for all products
            for (const product of products) {
              if (!allowedManagers[product] || !allowedManagers[product].includes(commenterLogin)) {
                console.log(`Comment by ${commenterLogin} is not from an authorized manager for product ${product}. Exiting.`);
                return;
              }
            }

            // Calculate cron expression from start date and time
            const startDateTime = new Date(startDate);
            const cronExpression = `${startDateTime.getUTCMinutes()} ${startDateTime.getUTCHours()} ${startDateTime.getUTCDate()} ${startDateTime.getUTCMonth() + 1} *`;

            // Update the workflow file with the new schedule
            const fs = require('fs');
            const path = require('path');
            const workflowFilePath = path.join(process.env.GITHUB_WORKSPACE, '.github', 'workflows', `start-${products[0].toLowerCase().trim()}-env.yml`);

            if (!fs.existsSync(workflowFilePath)) {
              console.error(`Workflow file does not exist: ${workflowFilePath}`);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `Error: Workflow file for product **${products[0]}** does not exist. Please check the workflow configuration.
                CRON: ${cronExpression}`
              });
              return;
            }

            let workflowContent = fs.readFileSync(workflowFilePath, 'utf8');
            if (workflowContent.includes('schedule:')) {
              workflowContent = workflowContent.replace(/schedule:\n\s+- cron: '.*'/, `schedule:\n  - cron: '${cronExpression}'`);
            } else if (workflowContent.includes('on:')) {
              workflowContent = workflowContent.replace(/on:/, `on:\n  schedule:\n    - cron: '${cronExpression}'`);
            } else {
              workflowContent = `on:\n  schedule:\n    - cron: '${cronExpression}'\n` + workflowContent;
            }
            fs.writeFileSync(workflowFilePath, workflowContent);

            // Commit the changes
            await github.rest.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: `.github/workflows/start-${products[0].toLowerCase().trim()}-env.yml`,
              message: `Update schedule for product ${products[0]} workflow`,
              content: Buffer.from(workflowContent).toString('base64'),
              sha: (await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: `.github/workflows/start-${products[0].toLowerCase().trim()}-env.yml`
              })).data.sha
            });

            // Update the issue with the approval details
            let approvalDetails = '| Product | Approved By |\n| --- | --- |\n';
            for (const product of products) {
              approvalDetails += `| ${product} | ${commenterLogin} |\n`;
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `Workflow for product(s) **${products.join(', ')}** in environment **${environment}** scheduled successfully. Dates: Start: **${startDate}**, End: **${endDate}**.\n\n### Approval Details\n${approvalDetails}`
            });

